import molpher
import warnings

from molpher.core.ExplorationData import ExplorationData
from molpher.core.MolpherMol import MolpherMol
from molpher.core.operations import TraverseCallback, TraverseOper

class Callback(TraverseCallback):
    """
    :param callback: callable with one positional argument
    :type callback: any callable object

    Basic callback class used to traverse the tree in `ExplorationTree.traverse()` method.

    It registers a callable and calls it every time a `morph` is processed.

    """

    def __init__(self, callback):
        super(Callback, self).__init__()
        self._callback = callback

    def __call__(self, morph):
        """
        Calls the registered callback for a `morph`

        :param morph: morph in a tree
        :type morph: `MolpherMol`
        """

        morph.__class__ = MolpherMol
        self._callback(morph)

class ExplorationTree(molpher.swig_wrappers.core.ExplorationTree):
    """
    :param params: the morphing parameters (optional if ``source`` is specified)
    :type params: `molpher.swig_wrappers.core.ExplorationData` or any of its derived classes or a `dict` of parameters to `molpher.core.ExplorationData`
    :param source: SMILES of the source molecule
    :type source: `str`
    :param target: SMILES of the target molecule (optional)
    :type target: `str`

    ..  note:: When ``params`` are specified, ``source`` and ``target`` are ignored.

    ..  note:: If the target molecule is missing a single carbon atom is supplied instead as a placeholder.

    This specialized version of `molpher.swig_wrappers.core.ExplorationTree`
    implements some additional functionality for ease of use from Python.

    """

    def __init__(self):
        super(ExplorationTree, self).__init__()

    @staticmethod
    def _cast_mols(mols):
        ret = [ x for x in mols ]
        for morph in ret:
            morph.__class__ = MolpherMol
        return ret

    @staticmethod
    def create(params=None, source=None, target=None):
        ret = None
        if params and (source or target):
            warnings.warn(
                "Both parameters and source, target or snapshot specified. Using the values in parameters..."
                , RuntimeWarning
            )
        if params and isinstance(params, molpher.wrappers.ExplorationData):
            ret = super(ExplorationTree, ExplorationTree).create(params)
        elif params:
            _params = ExplorationData(**params)
            ret = super(ExplorationTree, ExplorationTree).create(_params)
        elif source and target:
            ret = super(ExplorationTree, ExplorationTree).create(source, target)
        else:
            raise AttributeError('Invalid set of parameters specified.')

        if not ret:
            raise RuntimeError('No tree initilized.')

        ret.callback_class = Callback
        ret.__class__ = ExplorationTree

        return ret

    @property
    def params(self):
        """
        A dictionary representing the current `exploration parameters`.

        It is possible to assign a new dictionary to update the current parameters.
        Only parameters defined in the supplied dictionary are changed.

        :return: current parameters
        :rtype: `dict`
        """
        params = ExplorationData(other=self.asData())
        return params.param_dict

    @params.setter
    def params(self, params):
        if isinstance(params, molpher.wrappers.ExplorationData):
            self.update(params)
        else:
            new_params = self.params
            new_params.update(params)
            data = ExplorationData(**new_params)
            self.update(data)

    @property
    def generation_count(self):
        """
        Number of `morph generations <morph generation>` connected to the tree so far.

        :return:
        :rtype: `int`
        """

        return self.getGenerationCount()

    @property
    def path_found(self):
        """
        Shows if the `target molecule` is present in this tree.

        :return:
        :rtype: `bool`
        """

        return self.isPathFound()

    @property
    def leaves(self):
        """
        The current leaves of the tree.

        :return: the current leaves of the tree as instances of `MolpherMol`
        :rtype: `tuple`
        """

        return tuple(self._cast_mols(self.fetchLeaves()))

    @property
    def candidates(self):
        """
        Moprhs generated by a single call to `generateMorphs()`.

        :return: the `candidate morphs` as instances of `MolpherMol`
        :rtype: `tuple`
        """
        return tuple(self._cast_mols(self.getCandidateMorphs()))

    @property
    def candidates_mask(self):
        """
        A `tuple` of `bool` objects that serve as means of filtering the `candidate morphs`.
        Each `morph` in `candidates` has a `bool` variable assigned to it in this `tuple`
        -- only morphs with `True` at the appropriate position are added to the tree when `extend`
        is called.

        It can be changed by supplying a new one to the `setCandidateMorphsMask()` method.

        :return: currently selected `candidate morphs` represented as a `tuple` of `bool` objects
        :rtype: `tuple`
        """

        return self.getCandidateMorphsMask()

    @candidates_mask.setter
    def candidates_mask(self, mask):
        self.setCandidateMorphsMask(mask)

    @property
    def thread_count(self):
        """
        Maximum number of threads this instance will use for its computations.

        :return: number of threads
        :rtype: `int`
        """

        return self.getThreadCount()

    @thread_count.setter
    def thread_count(self, val):
        self.setThreadCount(val)

    def fetchMol(self, canonSMILES):
        ret = super(ExplorationTree, self).fetchMol(canonSMILES)
        ret.__class__ = MolpherMol
        return ret

    def traverse(self, callback, start_mol = None):
        """
        This method can be used to traverse the whole tree structure (or just a subtree)
        starting from root to leaves.

        The method takes a callback function that accepts a single argument. It then
        traverses the whole tree starting from its root (or root of a specified subtree) and
        calls the supplied function with the currently encountered morphs as its argument.

        A subtree can be specified by supplying its root as the optional ``start_mol`` argument.

        :param callback:
        :type callback: a callable object that takes a single argument
        :param start_mol: the root of a subtree to explore as canonical SMILES or `MolpherMol` instance
        :type start_mol: `str` or `MolpherMol`
        :return:
        :rtype:
        """

        if start_mol and type(start_mol) == MolpherMol:
            TraverseOper(self, self.callback_class(callback), start_mol)()
        elif start_mol:
            mol = self.fetchMol(start_mol)
            TraverseOper(self, self.callback_class(callback), mol)()
        else:
            cb = self.callback_class(callback)
            TraverseOper(self, cb)()